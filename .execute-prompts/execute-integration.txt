You are implementing an integration plan for a project.

## Integration Plan

# Real Visitor Counter Implementation

This plan outlines the implementation of a real visitor counter for a website, focusing on tracking total page views and displaying the count on a public-facing page. It includes details on data storage, architecture, APIs, and testing strategies.

## Implementation Plan

# Overview and Requirements

Track total page views on the Next.js application and display the count on a public-facing page. Counter increments by one per page load, with no unique visitor or session tracking.

Store counts in PostgreSQL/MongoDB. Display counter on single public page (homepage or stats page). Accept 5-30 second delay in updates. Requires database schema changes.

# Architecture and Design

Client-side JavaScript sends a POST request to `/api/track-visitor` on page load. The request fires asynchronously without blocking page rendering. Server increments a visitor counter in PostgreSQL/MongoDB on each request. A dedicated stats page queries and displays the current counter value.

Data flows: page load → API call → database increment → stats page query. The counter increments by one per page load. A 5-30 second delay between page load and counter update is acceptable.

# Data Structures and Storage

## Schema

Single `visitor_counts` table with columns: `id` (primary key), `page_identifier` (indexed string), `view_count` (integer), `last_updated_at` (timestamp). One row per tracked page. No session tracking, unique visitor breakdown, or IP storage.

## Storage and Updates

PostgreSQL or MongoDB. Atomic view count increment on each page load with timestamp update. 5-30 second delay acceptable before count displays on stats page. Indefinite retention. No archival policy required.

# APIs and Integration Points

POST `/api/visitors/track` increments the page view counter on each page load. Request contains timestamp, page URL, and referrer. No authentication required.

GET `/api/visitors/count` returns current page view total as JSON: `{ "count": number }`. No authentication required for public display.

Data writes to PostgreSQL/MongoDB with schema change to existing database. Simple schema stores page view records with timestamp. Real-time data delivery with 5-30 second acceptable delay.

# Step-by-Step Implementation Flow

Each page load sends a POST request to `/api/visitors`. The server increments the total_count field in the PostgreSQL visitors table and returns the updated value.

The counter is displayed on a single public-facing page. Updates reach active clients within 5-30 seconds. No deduplication occurs—the count increments on every page load.

# Edge Cases, Failure Modes, and Risks

**Bot Traffic and Concurrent Counting**: Crawlers inflate page view counts without filtering. Multiple simultaneous requests create race conditions requiring atomic increment operations. Use user-agent filtering (Googlebot, Bingbot) or implement row-level locking to prevent undercounting.

**Schema Migration and Storage**: PostgreSQL/MongoDB schema change required for counter storage. Unbounded growth necessitates purging old records based on retention policy. Plan zero-downtime migration with rollback procedures.

**Privacy Compliance and Data Accuracy**: GDPR/CCPA require consent for tracking and automated data deletion. JavaScript-only tracking misses disabled-JS clients. The specified 5-30 second display delay is acceptable for the single public-facing page; at high concurrency, accept that displayed count lags actual count or cache results for faster reads.

# Testing, Validation, and Measurement

## Test Coverage

Unit tests verify the increment operation increments count by 1 per page load. Integration tests confirm 100 concurrent requests complete without data loss. Test the counter accuracy with requests sent at 5-30 second intervals and verify PostgreSQL/MongoDB storage.

## Performance Benchmarks

Response time for the increment endpoint: under 100ms at 95th percentile under 1000 requests per minute. Display page load and render: under 500ms. Counter accuracy: within 1 page view across all scenarios.

# Constraints and Technical Considerations

Database schema changes required in PostgreSQL or MongoDB to store visitor counts. Table/collection must include fields for page identifier, total views, and last updated timestamp. Increments on each page load without deduplication.

Display on single page only (homepage or stats page). Real-time display with 5-30 second delay acceptable. No rate limiting required for simple increment operations. Requires JavaScript enabled on client.

No GDPR/CCPA compliance requirements if limiting stored data to page views only. No third-party dependencies—implementation self-contained within existing database.

## Your Task

Follow the plan above step-by-step to implement the integration. The plan has been generated with all necessary context and steps.

IMPORTANT:
- Follow the plan exactly as written
- Complete all setup, integration, and verification steps
- Make all necessary code changes
- Install any required packages
- The plan is cached in AI cache for reference
