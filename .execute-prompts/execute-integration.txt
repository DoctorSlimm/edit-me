You are implementing an integration plan for a project.
You don't have access to any external service or storage, don't add them even if the plan specifies them.

## Integration Plan

# Color Picker Preferences Implementation

This plan outlines the implementation of a color picker preferences feature using local storage for session-only persistence, addressing API errors, and ensuring synchronization across browser tabs.

## Implementation Plan

# Overview & Problem Statement

The PUT `/api/colors/preferences` endpoint fails with HTTP 500 errors because `updateUserColorPreferences()` attempts database access, which is unavailable in the sandbox environment. The solution: store color preferences in browser local storage and use the API only for validation and tab synchronization.

Color preferences persist for the current browser session only, clearing on page close. Users store one active palette preference. The API validates incoming color values (`preferred_palette_id` as number, `theme_settings` as object, `background_inverted` as boolean) and broadcasts changes across browser tabs.

# Requirements & Constraints

Color preference updates fail with HTTP 500 errors due to unavailable backend database access in the sandboxed environment. Persistence occurs entirely in browser local storage.

**Functional:** Color preferences persist only within the current browser session and clear on close. User selects one active color preference. API endpoint validates input (`preferred_palette_id` number, `theme_settings` object, `background_inverted` boolean) and returns HTTP 400 for invalid requests.

**Non-Functional:** No external database access permitted. API calls are made for state synchronization across tabs but are non-blocking—failures do not prevent UI updates. Local storage is the only persistence mechanism.

# API Specification

## PUT /api/colors/preferences

Validates color preferences and syncs state across tabs using browser local storage only.

### Request Body
```json
{
  "preferred_palette_id": number,
  "theme_settings": object,
  "background_inverted": boolean
}
```
At least one field required. All fields optional.

### Success Response (200)
```json
{
  "user_id": string,
  "preferred_palette_id": number,
  "theme_settings": object,
  "background_inverted": boolean,
  "updated_at": string
}
```

### Error Responses
- **400**: Invalid field type or no fields provided. Response includes specific field that failed validation.
- **500**: Local storage update failed.

### Validation
- `preferred_palette_id` must be a number
- `theme_settings` must be an object
- `background_inverted` must be a boolean
- Clears on browser close (session-only, no persistence)

# Data Structures & Storage Schema

## Local Storage

Color preferences store in browser localStorage under key `user:colors:preferred_palette_id` with value as numeric palette ID (string). Session scope: localStorage clears on browser close.

API endpoint `PUT /api/colors/preferences` validates incoming data: `preferred_palette_id` (number), `theme_settings` (object), `background_inverted` (boolean). Invalid types return HTTP 400. Server-side code checks `typeof window === 'undefined'` to prevent errors during SSR.

## User Color Preferences Object

- `preferred_palette_id`: number (palette ID 1-3: red/green/halloween)
- `theme_settings`: object (reserved; empty for current implementation)
- `background_inverted`: boolean (stored separately under `user:theme:background-inverted`)

Single preference at a time. No multi-preference support.

## Color Palette Cache

Color palettes cached in memory as `Map<number, ColorPalette>` with variants array per palette. No duplicate API queries in same session.

# Component Architecture & Interaction

ColorPaletteSwitcher triggers ThemeProvider.setActiveColorPalette(), which applies the palette to the DOM via applyColorVariantsToDOM() by setting CSS variables on the document root, then sends a PUT request to /api/colors/preferences with the palette_id. The API validates the palette_id and returns the updated preference object; if the API call fails, the client state remains applied on the DOM.

**Data Flow:** User clicks palette button → setActiveColorPalette(paletteId) → applyColorVariantsToDOM() updates CSS variables → fetch PUT /api/colors/preferences { preferred_palette_id: paletteId }. The API response validates and returns the stored preference, enabling state synchronization across multiple tabs.

**Storage:** Client state in ThemeProvider holds the active palette. Preferences persist only during the browser session (cleared on browser close). The API endpoint stores preferences in memory and validates all inputs; no database is used.

# Error Handling & Edge Cases

HTTP 500 responses from PUT /api/colors/preferences do not prevent UI state changes. The component updates DOM and state immediately, then attempts API sync asynchronously. API failures log warnings; failed requests are not retried.

Input validation at the API layer type-checks `preferred_palette_id` (number), `theme_settings` (object), and `background_inverted` (boolean), returning HTTP 400 for invalid types. Requests with no valid fields return HTTP 400. Hex colors validate against regex `^#[0-9A-Fa-f]{6}$`. Invalid palette IDs cause component to throw error without updating state.

Local storage quota exhaustion logs a warning and silently fails—state continues in memory but persistence is lost on page reload. Browser session close automatically deletes all stored preferences. Non-existent palette IDs during initialization fall back to the first available palette.

# Testing & Validation Strategy

## Unit Tests
Test `ColorPaletteSwitcher.tsx` renders selected palette with bold font weight and blue background. Verify clicking palette calls `setActiveColorPalette` handler. Test `PUT /api/colors/preferences` rejects invalid `preferred_palette_id` (non-number), `theme_settings` (non-object), and `background_inverted` (non-boolean) with HTTP 400. Verify HTTP 200 returns updated preferences.

## Storage & Sync
Test `ThemeProvider` persists palette selection to localStorage across page refreshes within the same session. Verify localStorage clears on browser close. Verify API call fails without breaking local state update. Test multiple tabs see palette changes via storage event listeners.

## Error Handling
Verify error displays in red panel when API returns HTTP 500. Verify component continues functioning when API sync fails (state updated locally). Verify error clears on retry. Confirm `console.warn` logs API failures without throwing.

## Your Task

Follow the plan above step-by-step to implement the integration. The plan has been generated with all necessary context and steps.

IMPORTANT:
- Follow the plan exactly as written
- Complete all setup, integration, and verification steps
- Make all necessary code changes
- Install any required packages
- The plan is cached in AI cache for reference